# -*- coding: utf-8 -*-
"""Practica 8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10StNKwLZ0Pnv6J0Ol7H8NEwRR8Ny2hH3

<font color="Teal" face="Comic Sans MS,arial">
  <h1 align="center"><i> Practica 8 </i></h1>
  </font>
  <h3 align="center"><i>  </i></h3>
  </font>
  <font color="Black" face="Comic Sans MS,arial">
  <h4 align="center"><i> Bases de datos estructuradas</i></h5>
  <h5 align="center"><i>Autores: Mosqueda García Raul Isaid 315096574</i></h5>
  <h5 align="center"><i>  Ruiz Puga Ingrid Pamela 314012926</i></h5>
  <h5 align="center"><i>  Veleros Vega Luis Alfonso 314271646</i></h5>
 </font>

---

Para esta practica se operara con los csv descargados de la base de datos del servidor.

#1. 
Se desea saber con base en la información de los clientes que han pedido préstamo personal. Quienes son
los más adecuados para promocionarles algún préstamo hipotecario. Generar grafica o reporte que permita saber el
patrón de manejo de cuenta (por ejemplo) y clasificarlo/agruparlo como buen prospecto para préstamo hipotecario.
¿Qué puede concluir, recomendar o decisión tomar a partir de esta información?
"""

!pip install pandasql

import pandas as pd
import numpy as np
import pandasql as ps
import matplotlib.pyplot as plt
import plotnine as p9
import datetime
from sklearn import linear_model

hechos=pd.read_csv('hechos_estrella.csv')
cliente=pd.read_csv('cliente.csv')
producto=pd.read_csv('producto.csv')
tiempo=pd.read_csv('tiempo.csv')

"""En primera instancia vamos a descartar a las personas que ya tienen hipoteca. Pues dado que ya tienen una deuda buscaremos que la cubran para poder ofrecerles otro prestamo hipotecario"""

q1="""SELECT cliente.cliente_id, cliente.nombre_cliente, cliente.ingreso,
producto.tipo_producto_desc,producto.producto_id,producto.producto_desc,
tiempo.fecha, hechos.saldo_$ as saldo,producto.numero_cuenta
FROM hechos
JOIN cliente ON cliente.llave_cliente == hechos.llave_cliente
JOIN producto ON producto.llave_producto == hechos.llave_producto
JOIN tiempo ON tiempo.llave_tiempo == hechos.llave_tiempo
WHERE producto.tipo_producto_desc != "Mortgage"
"""
data = ps.sqldf(q1,locals())

#Cambiamos el tipo de dato a fecha para operar con esta columna.
data['fecha'] = pd.to_datetime(data['fecha'], format='%d/%m/%Y')
data.sort_values(by='fecha')
#data.index = data['fecha']

"""Dado que ya sabemos las personas que tienen prestamos hipotecarios, veremos el comportamiento de los saldos de las personas que aun son candidatas para ofrecerles un prestamo"""

q2="""SELECT cliente.cliente_id, cliente.nombre_cliente, cliente.ingreso,
producto.tipo_producto_desc,producto.producto_id,producto.producto_desc,
tiempo.fecha, hechos.saldo_$ as saldo,producto.numero_cuenta
FROM hechos
JOIN cliente ON cliente.llave_cliente == hechos.llave_cliente
JOIN producto ON producto.llave_producto == hechos.llave_producto
JOIN tiempo ON tiempo.llave_tiempo == hechos.llave_tiempo
WHERE nombre_cliente != "Redfern" AND nombre_cliente != "Richards" 
"""
datash = ps.sqldf(q2,locals())
datash

#Cambiamos el tipo de dato a fecha para operar con esta columna.
datash['fecha'] = pd.to_datetime(datash['fecha'], format='%d/%m/%Y')
datash.sort_values(by='fecha')
datash.index = datash['fecha']
#datash.resample("M").sum()

"""La grafica muestra que Anderson, Antoni y Rivera son las personas que son factibles al prestamo, pero podemos ver mucha variación en sus saldos (los picos) debido a que esos saldos pueden venir de distintas cuentas. Por lo que veremos con mas detalle como se comportan para los presuntos candidatos."""

(p9.ggplot(data= datash,
           mapping=p9.aes(x='fecha',
                          y='saldo',
                          color='nombre_cliente'))
    + p9.geom_line()
)

"""Veamos por candidato"""

q3="""SELECT tiempo.fecha, hechos.saldo_$ as saldo, producto.producto_desc
FROM hechos
JOIN cliente ON cliente.llave_cliente == hechos.llave_cliente
JOIN producto ON producto.llave_producto == hechos.llave_producto
JOIN tiempo ON tiempo.llave_tiempo == hechos.llave_tiempo
WHERE producto.tipo_producto_desc != "Mortgage" AND cliente.nombre_cliente =="Rivera"
"""

q4="""SELECT tiempo.fecha, hechos.saldo_$ as saldo, producto.producto_desc
FROM hechos
JOIN cliente ON cliente.llave_cliente == hechos.llave_cliente
JOIN producto ON producto.llave_producto == hechos.llave_producto
JOIN tiempo ON tiempo.llave_tiempo == hechos.llave_tiempo
WHERE producto.tipo_producto_desc != "Mortgage" AND cliente.nombre_cliente =="Antoni"
"""

q5="""SELECT tiempo.fecha, hechos.saldo_$ as saldo, producto.producto_desc
FROM hechos
JOIN cliente ON cliente.llave_cliente == hechos.llave_cliente
JOIN producto ON producto.llave_producto == hechos.llave_producto
JOIN tiempo ON tiempo.llave_tiempo == hechos.llave_tiempo
WHERE producto.tipo_producto_desc != "Mortgage" AND cliente.nombre_cliente =="Anderson"
"""
Rivera = ps.sqldf(q3,locals())
Antoni = ps.sqldf(q4,locals())
Anderson = ps.sqldf(q5,locals())

#Cambiamos el tipo de dato a fecha para operar con esta columna.
Rivera['fecha'] = pd.to_datetime(Rivera['fecha'], format='%d/%m/%Y')
Rivera.sort_values(by='fecha')
Rivera.index = Rivera['fecha']
#Antoni.resample("M").sum()

Antoni['fecha'] = pd.to_datetime(Antoni['fecha'], format='%d/%m/%Y')
Antoni.sort_values(by='fecha')
Antoni.index = Antoni['fecha']
#Antoni.resample("M").sum()

Anderson['fecha'] = pd.to_datetime(Anderson['fecha'], format='%d/%m/%Y')
Anderson.sort_values(by='fecha')
Anderson.index = Anderson['fecha']
#Antoni.resample("M").sum()

"""Rivera tiene dos cuentas, la de cheking of children y Line of credit. El saldo en su linea de credito ha ido disminuyendo considerablemente por lo que podriamos pensar que ha estado consumiento (utilizando su linea de credito) y tiene esas deudas con el banco, por lo que posiblemente no seria en candidato ideal."""

(p9.ggplot(data= Rivera,
           mapping=p9.aes(x='fecha',
                          y='saldo',
                          color='producto_desc'))
    + p9.geom_line()
)

"""Anderson también tiene dos cuenras, la de checking interest y regular checking, en ambas cuentas podemos ver que tiene una tendencia creciente. Aparte que en este caso Anderson tiene cuentas donde el dinero no es credito sino propio, por lo tanto Anderson es un buen candidato para ofrecerle el prestamo hipotecario."""

(p9.ggplot(data= Anderson,
           mapping=p9.aes(x='fecha',
                          y='saldo',
                          color='producto_desc'))
    + p9.geom_line()
)

"""An igual que Andeson, Antoni tiene dos cuentas una de On Line cheking y otra de Regular checking, de aquí podemos observar que la tendencia es creciente. Pero sobre todo la cuenta de Regular Saving tiende a crecer muy rapidamente por lo que tambien es un prospecto con potenciales recursos para cumplir con su deuda."""

(p9.ggplot(data= Antoni,
           mapping=p9.aes(x='fecha',
                          y='saldo',
                          color='producto_desc'))
    + p9.geom_line()
)

"""#2. 
Se desea saber cuáles son las características de los clientes que por lo regular no terminan de pagar su préstamo hipotecario. ¿Qué puede concluir, recomendar o decisión tomar a partir de esta información?
"""

q5="""SELECT cliente.cliente_id, cliente.nombre_cliente, cliente.ingreso,
producto.tipo_producto_desc,producto.producto_id,producto.producto_desc,
tiempo.fecha, hechos.saldo_$ as saldo,producto.numero_cuenta
FROM hechos
JOIN cliente ON cliente.llave_cliente == hechos.llave_cliente
JOIN producto ON producto.llave_producto == hechos.llave_producto
JOIN tiempo ON tiempo.llave_tiempo == hechos.llave_tiempo
WHERE producto.tipo_producto_desc == "Mortgage"
"""
hipoteca = ps.sqldf(q5,locals())
hipoteca

"""Tomando solo los clientes que cuentan con un prestamo hipotecario veamos que ambos han pagado con distinta velocidad y aún tienen la deuda."""

hipoteca['fecha'] = pd.to_datetime(hipoteca['fecha'], format='%d/%m/%Y')
hipoteca.sort_values(by='fecha')
hipoteca.index = hipoteca['fecha']

"""Redfern y Richards tienen su prestamo vigente con la diferencia y Richard ha pagado montos mayores en los ultimos meses pero ambos a;un deben al banco. Cabe notar que el prestamo de Richard fue mucho mayor al de Redfern"""

(p9.ggplot(data= hipoteca,
           mapping=p9.aes(x='fecha',
                          y='saldo',
                          color='nombre_cliente'))
    + p9.geom_line()
)

"""Entre las pocas características que se pueden observar de los clientes con deuda hipotecaria es que tienen edad de 60 + por lo que se puede recomentar al banco que procure otorgar estos prestamos a personas un poco más jovenes con mayor solvencia. Podria ser con un monto de ingresos elevado por ejemplo."""

q6="""SELECT cliente.nombre_cliente,
cliente.edad, 
cliente.ingreso,
cliente.estadocivil
FROM hechos
JOIN cliente ON cliente.llave_cliente == hechos.llave_cliente
JOIN producto ON producto.llave_producto == hechos.llave_producto
JOIN tiempo ON tiempo.llave_tiempo == hechos.llave_tiempo
WHERE producto.tipo_producto_desc == "Mortgage"
GROUP BY  cliente.nombre_cliente
"""
caracteristicas = ps.sqldf(q6,locals())
caracteristicas

"""#3
Se desea saber con base a la edad del cliente, el tipo de prestamo y su desempeño de pagos, la fecha aproximada de termino de pago de dicho prestamo. 

"""

#Cargar los datos 
facts = pd.read_csv('/content/hechos_estrella.csv')
clients = pd.read_csv('/content/cliente.csv')
product = pd.read_csv('/content/producto.csv')
time = pd.read_csv('/content/tiempo.csv')

"""Para esto, primero generamos una tabla donde se tengan las fechas de nacimiento de los clientes, sus prestamos y sus saldos."""

#Guardamos en una tabla el dataframe correspondiente a las fechas de nacimiento de los clientes, sus prestamos y sus saldos. 
q1="""SELECT 
nombre_cliente, edad, producto_desc,saldo_$,fecha
FROM
clients, facts, product, time
WHERE
facts.llave_cliente = clients.llave_cliente 
AND
tipo_producto_desc = 'Mortgage'
AND
facts.llave_producto = product.llave_producto
AND
facts.llave_tiempo = time.llave_tiempo;"""
data = ps.sqldf(q1,locals())
data

"""Con esta informacion, la forma dwe realizar las predicciones es ajustando un modelo de regresion lineal. Por la forma en la que se tienen los datos, se busca entonces predecir la fecha de los siguientes pagos hasta que el saldo sea 0. 

El modelo de regresion consiste en predecir la variable de tiempo con la variable de saldo como explicativa, para un tipo de hipoteca de un tipo de usuario dado.

Este modelo ajusta una recta para los saldos y fechas realizados hasta la edad determinada, y proyecta sobre esta los saldos hasta que se llegue a 0, y regresa la fecha de cuando el saldo sea 0.
"""

#Teniendo la informacion que se requiere, se toma una funcion donde se toma el cliente
def predict_time_last_payment(name,age,mortgage,data = data):
  #Excepciones
  if name not in set(data['nombre_cliente']): raise Exception ('La persona %s no es cliente con hipoteca'%name)
  if mortgage not in set(data['producto_desc']): raise Exception ('Actualmente no se tienen cuentas con la hipoteca %s'%mortgage)

  data_ = data[data['producto_desc']==mortgage]
  data_ = data[data['nombre_cliente']==name]
  data_ = data_[data['edad'] <= age]
  data_['fecha']=pd.to_datetime(data_['fecha'], format='%d/%m/%Y')
  
  x = np.array(data_['saldo_$']).reshape((-1, 1))
  y = list(data_['fecha'].apply(lambda x: x.toordinal()))
  regr = linear_model.LinearRegression()
  regr.fit(x, y)

  x_new = np.arange(x[-1],0,-100).reshape((-1, 1))
  y_pred = regr.predict(x_new)

  for i in range(len(y)):
    y[i] = datetime.date.fromordinal(y[i])

  plt.plot(y,x,'.')
  plt.plot(y_pred,x_new,'.')
  plt.xlabel('Tiempo')
  plt.ylabel('Saldo')
  plt.xticks(rotation=45)
  plt.title('Proyeccion de deuda del cliente %s'%name)
  plt.show()
  last_paymet = datetime.date.fromordinal(int(y_pred[-1]))
  print("El ultimo pago de %s sera el:%s"%(name,last_paymet))

predict_time_last_payment('Richards',68,'15 Year Mortgage')

predict_time_last_payment('Redfern',63,'Second Home Mortgage')

"""Con las cuentas disponbles actualmente, se puede ver que la frecuencia de los pagos y su magnitud impacta de manera significante la proyeccion de los proccimos, donde si los pagos no son constentes en cantidad o frecuencia, se puede esperar un largo periodo de pago, mientras que si los pagos son frecuentes en monto o frecuencia, el modelo predice que su terminacion de pagos sera mucho mas proxima.

La forma de obtener inrgesos con estos pagos es incluir penalicaciones (que se volveran ingresos para la reserva de riesgos y de ser cubiertos, ingresos para el banco) donde se aplicaran estas penalizaciones en caso de realizare los pagos con retraso, la 'bonificacion' para las personas que paguen a tiempo sera no realizarles la penalizacion.

##4
Se desea saber cuales son los productos que menor actividad(interes por parte de los clientes) ha tenido. De tal forma que se pueda pensar en eliminar dicho producto del portafolio de serivicios/productos del banco.

Para esta consulta, primero crearemos la tabla que contenga las frecuencias de los tipos de productos.
"""

#Guardamos en una tabla el dataframe correspondiente a las frecuencias de los tipos de productos. 
q1="""SELECT 
producto_desc AS product, COUNT(Saldo_$) AS frequency
FROM
facts, product
WHERE
facts.llave_producto = product.llave_producto
GROUP BY 1
ORDER BY 2 ASC;"""
data = ps.sqldf(q1,locals())
data

"""Teniendo las frecuencias simplemente se ordenan los datos por frecuencias y se propone el $1/4$ mas bajo de estos productos para ser eliminado o remplazado. """

def products_to_pop(data=data):
  op_data = data.sort_values(by='frequency',ascending=True)
  ordered_products = list(op_data['product'])
  size_top_pop = len(ordered_products) // 4
  underwhelming_products = ordered_products[:size_top_pop+1]
  not_underwhelming_products = ordered_products[size_top_pop+1:]
  print('The products that are more ignored by clients are:',underwhelming_products)
  print('The products that should be kept are:',not_underwhelming_products)

products_to_pop()

"""En este caso debido a que casi todos los productos tienen las mismas frecuencias, gran parte del $1/4$ mas bajo es arbitrario pues se toma valores que comparten frecuencias con el resto. Para esto, el unico producto que se consideraria remplazar es el prestamo a 90 dias. Debido a la baja cantidad de prestamos realizados, si se desea mantener el producto, se pueden proponer promociones que incrementen el incentivo a los clientes por consumirlo, sin embargo una opcion que puede presentar mas ganancias para los bancos es realizar un producto similar al que tenga mas frecuencia, en este caso la aprtura de lineas de credito. 

Una forma de realizar este remplaso es hacer una linea de credito similar pero con distintas promociones encfocadas a otro tipo de clientes, de forma que se tengan los mismos rendimientos que la linea de credito que se tiene actualmente.

## 5. Se desea saber cual es la sucursal que menos actividad ha tenido (pocas aperturas de cuentas , pocos cllientes , pocos pagos , ahorros)

carguemos los datos necesarios para las consultas , dado que estamos hablando de sucursales y hechos
"""

!pip install pandasql

import numpy as np 
import pandas as pd 
import pandasql as ps

hechos = pd.read_csv('hechos_estrella.csv')
sucursal=pd.read_csv('sucursal.csv')
producto=pd.read_csv('producto.csv')

"""cambiamos el valor de 'saldo_$' con 'saldo' para su uso optimo"""

hechos2=hechos.rename(columns={'saldo_$':'saldo'})

"""ya con el cambio"""

hechos2.head()

sucursal.head()

producto.head()

"""veamos las suma de los saldos . En la sucursal con id 1004 (Suc_North Platte) vemos que es la que tiene mas saldo es decir mas operacion activas en cambio la sucursal con 1001 (Suc_Birmingham) vemos que tiene la menor cantidad de cuentas activas . centremonos en ello y en la comparacion con laguna de sus sucursales vecinas"""

q2=""" select llave_org ,sum(saldo) as saldo
from hechos2
join producto ON producto.llave_producto == hechos2.llave_producto
group by llave_org
"""
sucursal_t=ps.sqldf(q2,locals())
sucursal_t

"""estos son los datos de la sucursal con numeros mas bajos"""

t1=""" select llave_org ,saldo,tipo_producto_id
from hechos2
join producto ON producto.llave_producto == hechos2.llave_producto
where llave_org ==1001

"""
sucursalpobre=ps.sqldf(t1,locals())
sucursalpobre

"""sucursal con numeros altos"""

t6=""" select llave_org,saldo,tipo_producto_id
from hechos2
join producto ON producto.llave_producto == hechos2.llave_producto
where llave_org ==1003

"""
sucursalneutra=ps.sqldf(t6,locals())
sucursalneutra

"""numeros de sucursal 'promedio'"""

t2=""" select llave_org,saldo,tipo_producto_id
from hechos2
join producto ON producto.llave_producto == hechos2.llave_producto
where llave_org ==1004

"""
sucursalbuena=ps.sqldf(t2,locals())
sucursalbuena

from matplotlib import pylab as plt 
plt.rcParams['figure.figsize']=(10,9)
plt.style.use('ggplot')

#esta grafica mostrara los datos de la sucursal con mejores numeros vs la que menos tiene
f2= sucursalpobre.saldo.values
f1= sucursalbuena.saldo.values
f3=sucursalneutra.saldo.values
plt.scatter(f1,f2,s=10)

"""como se puede ver en la sucursal con mjeores numeros los puntos estan mas juntos (mas proximos entre si  ) en comparacion con la que menos tiene .
Para observar esto realizaremos el algorimto de k-medias para verlo mejor
"""

from sklearn.cluster import KMeans
X = np.array(list(zip(f1,f2)))
kmeans = KMeans(n_clusters=2)
kmeans = kmeans.fit(X)
y=kmeans.predict(X)
C_ = kmeans.cluster_centers_
C_

fig , ax = plt.subplots()
ax.scatter(X[:,0],X[:,1],c=y)
ax.scatter(C_[:,0],C_[:,1],marker='*',s=200,c='k')

"""podemos ver que los puntos de lado izquierdo estan proximos al centroide y en el lado derecho se  notan mas dispersos . Realizaremos algunas compraciones similares en las que intervenga la sucursal neutra"""

Y = np.array(list(zip(f2,f3)))
kmeans = KMeans(n_clusters=2)
kmeans = kmeans.fit(Y)
y=kmeans.predict(Y)
C_ = kmeans.cluster_centers_
C_

fig , ax = plt.subplots()
ax.scatter(Y[:,0],Y[:,1],c=y)
ax.scatter(C_[:,0],C_[:,1],marker='*',s=200,c='k')

Z = np.array(list(zip(f1,f3)))
kmeans = KMeans(n_clusters=2)
kmeans = kmeans.fit(Z)
y=kmeans.predict(Z)
C_ = kmeans.cluster_centers_
C_

fig , ax = plt.subplots()
ax.scatter(Z[:,0],Z[:,1],c=y)
ax.scatter(C_[:,0],C_[:,1],marker='*',s=200,c='k')

"""Podemos ver que el resuklta es similar al primer caso , la sucursal que menos actividades tiene  presenta una dispercion en sus puntos , entonces podemos decir que la sucursal Suc_Birmingham es la que menos actividad tiene en comparacion a las demas"""